#!/usr/bin/env node

const { Command } = require('commander');
const chalk = require('chalk');
const { listAccounts, searchAccounts } = require('../lib/commands/account');
const { 
  enableNetworkCostPassthrough, 
  disableNetworkCostPassthrough, 
  getNetworkCostPassthroughStatus,
  deleteNetworkCostPassthroughScheme 
} = require('../lib/commands/account-settings');
const { importCards } = require('../lib/commands/cards');
const { deleteCustomer, deleteAllCustomers, deleteCustomersByMetadata } = require('../lib/commands/customer');
const { generateTestAccounts } = require('../lib/commands/test-account');
const ProfileManager = require('../lib/profile-manager');

const program = new Command();

program
  .name('stripe-cli')
  .description('A CLI tool for making Stripe API calls')
  .version('1.0.0');

// Account list command
program
  .command('account.list')
  .description('List the first 50 Connect accounts')
  .option('-k, --key <key>', 'Stripe secret key (or set STRIPE_SECRET_KEY env var)')
  .option('-p, --platform <platform>', 'Use platform from .secrets config file')
  .option('-f, --format <format>', 'Output format (table, json)', 'table')
  .action(async (options) => {
    try {
      await listAccounts(options);
    } catch (error) {
      console.error(chalk.red('Error:'), error.message);
      process.exit(1);
    }
  });

// Account search command
program
  .command('account.search <searchTerm>')
  .description('Search Connect accounts using fuzzy matching (supports * wildcards)')
  .option('-k, --key <key>', 'Stripe secret key (or set STRIPE_SECRET_KEY env var)')
  .option('-p, --platform <platform>', 'Use platform from .secrets config file')
  .option('-f, --format <format>', 'Output format (table, json)', 'table')
  .action(async (searchTerm, options) => {
    try {
      options.searchTerm = searchTerm;
      await searchAccounts(options);
    } catch (error) {
      console.error(chalk.red('Error:'), error.message);
      process.exit(1);
    }
  });

// Account import card command
program
  .command('account.import.card')
  .description('Import card data from CSV file to a Stripe connected account')
  .option('-f, --file <file>', 'CSV file path (or use stdin: account.import.card -a <acct> < file.csv)')
  .option('-a, --account <account>', 'Platform account ID (required)')
  .option('-ca, --connected-account <connected_account>', 'Connected account ID associated with platform account')
  .option('-k, --key <key>', 'Stripe secret key (or set STRIPE_SECRET_KEY env var)')
  .option('-p, --platform <platform>', 'Use platform from .secrets config file')
  .option('--format <format>', 'Output format (table, json)', 'table')
  .option('--dry-run', 'Validate CSV without creating cards')
  .option('--verbose', 'Show detailed progress output')
  .option('--delimiter <delimiter>', 'CSV delimiter (default: comma)', ',')
  .option('-m, --metadata <key=value...>', 'Add metadata to imported customers (e.g. --metadata env=uat --metadata source=cli). If omitted, import_date is set automatically.')
  .option('--source <source>', 'CSV source format: cardpointe (same as --source-cardpointe)')
  .option('--source-cardpointe', 'CSV is CardPointe format')
  .action(async (options) => {
    try {
      if (options.sourceCardpointe || (options.source && options.source.toLowerCase() === 'cardpointe')) {
        options.source = 'cardpointe';
      }
      await importCards(options);
    } catch (error) {
      console.error(chalk.red('Error:'), error.message);
      process.exit(1);
    }
  });

// Account customer delete (single customer, --all, or --metadata)
program
  .command('account.customer.delete [customer_id]')
  .description('Delete a customer by ID, by metadata (--metadata key=value), or delete all (test keys only) with --all')
  .option('--all', 'Delete all customers on the account (test keys only, prompts for each)')
  .option('--metadata <key=value>', 'Search for customers with this metadata and delete them (prompts for each, e.g. --metadata import_date=2026-01-30T23:44:00.000Z)')
  .option('-k, --key <key>', 'Stripe secret key (or set STRIPE_SECRET_KEY env var)')
  .option('-p, --platform <platform>', 'Use platform from .secrets config file')
  .option('-a, --account <account>', 'Account context (platform or connected account)')
  .option('-ca, --connected-account <connected_account>', 'Connected account where the customer lives (overrides -a)')
  .option('--format <format>', 'Output format (table, json)', 'table')
  .action(async (customerId, options) => {
    try {
      if (options.metadata) {
        await deleteCustomersByMetadata(options);
      } else if (options.all) {
        await deleteAllCustomers(options);
      } else if (customerId) {
        options.delete = customerId;
        await deleteCustomer(options);
      } else {
        console.error(chalk.red('Error:'), 'Specify a customer ID, --metadata key=value, or --all (e.g. account.customer.delete cus_xxx or account.customer.delete --metadata import_date=2026-01-30T23:44:00.000Z or account.customer.delete --all).');
        process.exit(1);
      }
    } catch (error) {
      console.error(chalk.red('Error:'), error.message);
      process.exit(1);
    }
  });

// Network cost passthrough enable command
program
  .command('account.setting.network-cost.enable')
  .description('Enable network cost passthrough for a connected account')
  .option('-a, --account <account>', 'Connected account ID (required)')
  .option('-k, --key <key>', 'Stripe secret key (or set STRIPE_SECRET_KEY env var)')
  .option('-p, --platform <platform>', 'Use platform from .secrets config file')
  .action(async (options) => {
    try {
      await enableNetworkCostPassthrough(options);
    } catch (error) {
      console.error(chalk.red('Error:'), error.message);
      process.exit(1);
    }
  });

// Network cost passthrough disable command
program
  .command('account.setting.network-cost.disable')
  .description('Disable network cost passthrough for a connected account')
  .option('-a, --account <account>', 'Connected account ID (required)')
  .option('-k, --key <key>', 'Stripe secret key (or set STRIPE_SECRET_KEY env var)')
  .option('-p, --platform <platform>', 'Use platform from .secrets config file')
  .action(async (options) => {
    try {
      await disableNetworkCostPassthrough(options);
    } catch (error) {
      console.error(chalk.red('Error:'), error.message);
      process.exit(1);
    }
  });

// Network cost passthrough status command
program
  .command('account.setting.network-cost.status')
  .description('Get network cost passthrough status for a connected account')
  .option('-a, --account <account>', 'Connected account ID (required)')
  .option('-k, --key <key>', 'Stripe secret key (or set STRIPE_SECRET_KEY env var)')
  .option('-p, --platform <platform>', 'Use platform from .secrets config file')
  .action(async (options) => {
    try {
      await getNetworkCostPassthroughStatus(options);
    } catch (error) {
      console.error(chalk.red('Error:'), error.message);
      process.exit(1);
    }
  });

// Network cost passthrough delete scheme command
program
  .command('account.setting.network-cost.delete-scheme')
  .description('Delete a scheduled network cost passthrough scheme')
  .option('-a, --account <account>', 'Connected account ID (required)')
  .option('--scheme-id <scheme_id>', 'Scheme ID to delete (required)')
  .option('-k, --key <key>', 'Stripe secret key (or set STRIPE_SECRET_KEY env var)')
  .option('-p, --platform <platform>', 'Use platform from .secrets config file')
  .action(async (options) => {
    try {
      await deleteNetworkCostPassthroughScheme(options);
    } catch (error) {
      console.error(chalk.red('Error:'), error.message);
      process.exit(1);
    }
  });

// Test account generate command
program
  .command('test.account.generate')
  .description('Generate test connected accounts for all configured countries with card_payments and transfers capabilities and all KYC/KYB requirements filled in')
  .option('-k, --key <key>', 'Stripe secret key (or set STRIPE_SECRET_KEY env var)')
  .option('-p, --platform <platform>', 'Use platform from .secrets config file')
  .option('-f, --format <format>', 'Output format (table, json)', 'table')
  .option('-t, --test', 'Use test environment keys from profile')
  .option('-e, --environment <environment>', 'Environment to use (test or prod)', 'prod')
  .action(async (options) => {
    try {
      await generateTestAccounts(options);
    } catch (error) {
      console.error(chalk.red('Error:'), error.message);
      process.exit(1);
    }
  });

// Config platform list command
program
  .command('config.platform.list')
  .description('List all configured platforms and their settings')
  .action(async () => {
    try {
      const { getAvailablePlatforms, getDefaultProfile, getTestProfile, getPlatformConfig } = require('../lib/config-loader');
      
      const platforms = getAvailablePlatforms();
      const defaultPlatform = getDefaultProfile();
      const testPlatform = getTestProfile();
      
      console.log('Available Platforms:');
      console.log('');
      
      if (defaultPlatform) {
        console.log(`Default Platform: ${defaultPlatform}`);
      }
      
      if (testPlatform) {
        console.log(`Test Platform: ${testPlatform}`);
      }
      
      console.log('');
      
      platforms.forEach(platformName => {
        const platformConfig = getPlatformConfig(platformName);
        console.log(`[${platformName}]`);
        console.log(`  Account: ${platformConfig.account || 'Not configured'}`);
        console.log(`  Production Connected Account: ${platformConfig.prod_connected_account || 'Not configured'}`);
        console.log(`  Test Connected Account: ${platformConfig.test_connected_account || 'Not configured'}`);
        console.log('');
      });
    } catch (error) {
      console.error(chalk.red('Error:'), error.message);
      process.exit(1);
    }
  });

program.parse();
